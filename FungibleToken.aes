contract FungibleToken =
  record state = {
    owner            : address,
    total_supply     : int,
    balances         : map(address, int),
    allowed          : map((address,address), int)}

  public stateful function init() = {
    owner = Call.caller,
    total_supply = 0,
    balances = {},
    allowed = {}}

  private function lookup_by_address(k : address, m, v) =
  	switch(Map.lookup(k, m))
	    None    => v
	    Some(x) => x

  public function total_supply() : int = state.total_supply

  public function balance_of(who: address) : int = lookup_by_address(who, state.balances, 0)

  public function allowance(owner: address, spender: address) : int =
    switch(Map.lookup((owner, spender), state.allowed))
	    None    => 0
	    Some(x) => x

  public stateful function transfer(to: address, value: int) : bool =
    transfer'(Call.caller, to, value)

  public stateful function approve(spender: address, value: int) : bool =
    require(value > 0, "Value is sub zero")
    require(spender != #0, "Invalid spender address")

    put(state{allowed[(Call.caller,spender)] = value})

    true

  private stateful function transfer'(from: address, to: address, value: int) : bool =
    require(value > 0, "Value is sub zero")
    require(value =< balance_of(from), "Not enough balance")
    require(to != #0, "Invalid address") // prevents burning of tokens by sending to address 0. Technically is a valid request

    put(state{
      balances[from] = sub(balance_of(from), value),
      balances[to] = add(balance_of(to), value)})

    true

  public stateful function transfer_from(from: address, to: address, value: int) : bool =
    require(state.allowed[(from, Call.caller)] >= value, "Value is bigger than allowed")

    put(state{allowed[(from, Call.caller)] = sub(state.allowed[(from, Call.caller)], value)})
    transfer'(from, to, value)

    true

  public stateful function increase_allowance(spender: address, added_value: int) : bool =
    require(spender != #0, "Invalid address")
    put(state{allowed[(Call.caller, spender)] = add(state.allowed[(Call.caller,spender)], added_value)})

    true

  public stateful function decrease_allowance(spender: address, subtracted_value: int) : bool =
    require(spender != #0, "Invalid address")
    put(state{allowed[(Call.caller,spender)] = sub(state.allowed[(Call.caller,spender)], subtracted_value)})

    true

  public stateful function mint(account: address, value: int) : bool =
    only_owner()
    require(account != #0, "Invalid address")

    put(state{total_supply = add(state.total_supply, value),
      balances[account] = add(balance_of(account), value)})

    true

  public stateful function burn(value: int) : bool =
    require(balance_of(Call.caller) >= value, "Burned amount is less than account balance")

    put(state{total_supply = sub(state.total_supply, value),
      balances[Call.caller] = sub(balance_of(Call.caller), value)})

    true

  private function add(a : int, b : int) : int =
    let c : int = a + b
    require(c >= a, "Error")
    c

  private function sub(a : int, b : int) : int =
    require(b =< a, "Error")
    a - b

  private function require(b : bool, err : string) =
    if(!b)
      abort(err)

  private function only_owner() =
    require(Call.caller == state.owner, "Only owner can mint!")